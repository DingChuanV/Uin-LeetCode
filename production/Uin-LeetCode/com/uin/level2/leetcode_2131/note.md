# 方法一：贪心 + 哈希表
## 思路与算法
根据回文串的定义，回文串可以由奇数或者偶数个 words 中的单词拼接而成，但必须满足以下条件：
  - 如果数量为奇数，那么位于正中间的单词必须是回文字符串（即两个字符相等）；
  - 每个单词和反转后对应位置的单词必须互为反转字符串。 

根据上面的两个条件，我们可以得出构造最长回文串的规则：
  - 对于两个字符不同的单词，需要尽可能多的成对选择它和它的反转字符串（如有）；
  - 对于两个字符相同的单词，需要尽可能多的成对选择该单词；
  - 如果按照上述条件挑选后，仍然存在未被选择的两个字符相同的单词（此时该字符串只可能有一个未被选择，
    且该字符串一定在 words 中出现奇数次），我们可以任意选择一个。

因此，我们用哈希表统计 words 中每个单词的出现次数。随后，我们遍历哈希表的所有元素， 并用 res 维护可能构成回文字符串的最长长度，同时用初值为 false 的布尔变量 mid 判断
是否存在可以作为中心单词的、出现奇数次的回文单词。

在遍历到字符串 word 时，我们首先求出它反转后的字符串 rev，此时根据 word 与 rev 的关系，有以下两种情况：
  - word!=rev，此时我们需要统计两者在 words 出现次数的最小值，即为成对选择的最多数目。
    假设此时对数为 nn，则其对最长回文字符串贡献的字符长度为 4n，我们将 res 加上对应值；
  - word=rev，此时可以构成的对数为 ⌊m/2⌋，即对最长回文字符串贡献的字符长度为 4⌊m/2⌋，我们同样将 res 加上对应值。
   
    除此以外，我们还需要判断 word 的出现次数 mm 是否为奇数：
    - 如果 mm 为奇数，则存在可以作为中心单词的剩余回文单词，我们将 mid 置为 true；
    - 如果 mm 为偶数，则不存在可以作为中心单词的剩余回文单词，我们不改变 mid 的取值。

最后，我们根据 mid 的取值，判断最长回文串是否含有中心单词。如果 mid 为 true，则代表含有，我们将 res 加上 2；反之则没有，我们不进行任何操作。

最后，我们返回 res 作为最长回文串的长度。

## 细节
在遍历哈希表的每个单词时，为了避免重复计算成对选择的单词。我们只在 ``word``  的字典序大于等于rev时更新res。


# 方法二： 
## 解题思路
其实这道题本质上和1.两数之和是一样的，也就是本题把两数之和中要寻找的target变为了回文子串
字符串本身是否为回文子串对我们所构建的最长回文子串有影响
例如:[lc, cl, gg, ll, gg, ll, gg, ccc]

 - 对于本身不为回文字符串的"lc"和"cl"可以位于我们最终所构建的字符串的两端(顺序无影响)，运用两数之和的思路进行求解即可
 - 对于本身为回文字符串的三个字符串分别为"gg", "ll", "ccc"
   - 如果某个字符串的个数为1，则该字符串为添加到最中心部分的字符串，我们需要统计这其中的最长的那个字符串的长度
   - 如果某个字符串的个数大于等于2，则将其两两添加到我们所构建的字符串两端，一次只能分走2个字符串，一直分下去，直到当该种字符串剩余为1或0时为止。
   - 若剩余个数为1，应当以个数为1时再次进行处理
   
基于以上思路和示例，我们所构建的最终的字串为"lcllggcccggllcl"

## 下面是具体的解题步骤
1. 创建两个哈希表，一个储存本身不是回文子串的字符串，另一个统计本身为回文字串的字符串
2. 遍历数组：若该字符串为非回文串，则检查map中是否有该字符串的反转字符串；若存在，则该反转字符串数量减一，否则储存该字符串。若该字符串为回文字符串，则先存入equal表中，后续再做处理
3. 遍历equal表，查找其中的每一个字串的数量，若数量为1，则用max储存其长度最大值；若大于等于2，则每次减少两个(这里使用除法即可)，直到剩余量为1或0。剩余为1时，我们再次按照数量为1时进行处理
4. 最终返回值为两边的回文子串数 + 中间部分的回文子串的最长长度

